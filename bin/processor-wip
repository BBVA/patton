#!/usr/bin/env python3

import sys
import json


_processors = []


def case(f):
    global _processors
    _processors = [f, *_processors]

    return f


def preserve_lineage(parent, child):
    preserved = dict()
    preserved['meta'] = parent['meta'].copy()
    preserved['meta']['ingest'] = {k: v for k, v in parent.items() if k != 'meta'}
    preserved.update(child)

    return preserved


@case
def debian_status_file(meta, data):
    if meta['source'] != 'debian' or meta['type'] != 'status file':
        return None
    processed = dict()
    if data['source'] == "":
        software_candidate = data['package']
    else:
        software_candidate = data['source']
    processed['version'] = data['version']

    # TODO: check if an alternate implementation where affixes are expressed as regexes
    # that are consumed and tried every time an affix is stripped, until exhausted
    processed['software'] = strip_affixes(
        ['python3-', 'python2-', 'python-', 'lib'],
        ['-dbg', '-dev', '-doc', '-examples', '-minimal', '-plugins', '-extra',
         '-perl', '-jni', '-java', '-ruby1.9', '-ruby1.8', '-ruby'],
        software_candidate)

    return processed


def strip_affixes(prefixes, suffixes, text):
    for prefix in prefixes:
        if text.startswith(prefix):
            text = text[len(prefix):]
    for suffix in suffixes:
        if text.startswith(prefix):
            text = text[:len(prefix)]
    return text


if __name__ == "__main__":
    for line in sys.stdin:
        data = json.loads(line)
        meta = data['meta']
        processed = map(lambda f: f(meta, data), _processors)
        valid = filter(lambda x: x is not None, processed)
        found = next(valid, None)
        if found:
            preserved_package = preserve_lineage(data, found)
            json.dump(preserved_package, sys.stdout)
        else:
            sys.stderr.write(line)
